/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32l476xx.h"
#include <stdio.h>
// create a led delay. Just a rough estimate
// for one second delay
int piso=0;
int actual;
int pos=1;
int con=0;
int lock=1;
int cam=1;
/*************************************************
* function declarations
*************************************************/
int main(void);
void GPIO_init(void);
void Ext_init(void);
void TIMER_init(void);
void elevator(void);

void TIM2_IRQHandler(void)
{

    // clear interrupt status
    if (TIM2->DIER & 0x01) {
        if (TIM2->SR & 0x01) {
            TIM2->SR &= ~(1U << 0);
        }
    }
		con +=1;
}
void EXTI15_10_IRQHandler(void)
{
	//Check if the interrupt came from exti13
	if(EXTI->PR1 & (1 <<13)) {
		piso += 1;
		cam=0;
		// Clear pending bit
		EXTI->PR1 = 0x00002000;
	}
}
int main(void)
{
	//Se inicializa las GPIO que se van a usar (Puerto A y C)
	GPIO_init();
	// Se configura la interrupción externa
	Ext_init();
	//Inicializamos el TIMER que marcara el tiempo de la secuencia
	TIMER_init();
	//Inicializamos la máquina de estados
	elevator();
	while(1)
	{

	}

	__asm__("NOP"); // Assembly inline can be used if needed
	return 0;
}

void GPIO_init(void){
	RCC->AHB2ENR |= 0x00000005;
	// Enable GPIOA and GPIOC Peripheral Clock (bit 0 and 2 in AHB2ENR register)
	// Make GPIOA Pin5 as output pin (bits 1:0 in MODER register)
	GPIOA->MODER &= 0xABFFFFFF;		// Clear bits 11, 10 for P5
	GPIOA->MODER &= 0xFFFFF755;		// Write 01 to bits 11, 10 for P5
	GPIOA->ODR &=0x0000;
	// Make GPIOD Pin13 as input pin (bits 27:26 in MODER register)
	GPIOC->MODER &= 0xFFFFFFFF;		// Clear bits 27, 26 for P13
	GPIOC->MODER &= 0xF3FFFFFF;		// Write 00 to bits 27, 26 for P13
}
void Ext_init(void){
    // enable SYSCFG clock
    	RCC->APB2ENR |= 0x1;
    	// Writing a 0b0010 to pin13 location ties PC13 to EXT4
    	SYSCFG->EXTICR[3] |= 0x20; // Write 0002 to map PC13 to EXTI4
    	// Choose either rising edge trigger (RTSR1) or falling edge trigger (FTSR1)
    	EXTI->RTSR1 |= 0x2000;   // Enable rising edge trigger on EXTI4
    	// Mask the used external interrupt numbers.
    	EXTI->IMR1 |= 0x2000;    // Mask EXTI4
    	// Set Priority for each interrupt request
    	NVIC->IP[EXTI15_10_IRQn] = 0x10; // Priority level 1
    	// enable EXT0 IRQ from NVIC
    	NVIC_EnableIRQ(EXTI15_10_IRQn);
}
void TIMER_init(void){
    // enable TIM2 clock (bit0)
    RCC->APB1ENR1 |= (1<<0);
    TIM2->PSC = 7999;
    TIM2->ARR = 400;
    // Update Interrupt Enable
    TIM2->DIER |= (1 << 0);
    NVIC_SetPriority(TIM2_IRQn, 2); // Priority level 2
    // enable TIM2 IRQ from NVIC
    NVIC_EnableIRQ(TIM2_IRQn);
    // Enable Timer 2 module (CEN, bit0)
    TIM2->CR1 |= (1 << 0);
}
void elevator(void){
	//Estados: En Movimiento, Inmovil y entrada salida
	enum states {En_Movimiento, Inmovil,entrada_salida} current_state;
	int lock=0;
	int t;
	current_state = Inmovil; //set the initial state
	GPIOA->ODR |=(1<<0);
	while(1){
//En caso de que se oprima más de tres veces el botón,
//Se interpretara como tres veces.
		if (piso>3){
			piso=3;
		}
		switch(current_state){
			case En_Movimiento:
//Guardamos el tiempo en el que se entró al estado
				if (lock==0){
					t=con;
					lock=1;
					GPIOA->ODR &= 0x00;
				}
//Se ejecutará cada segundo
				if (con>(t+1)){
//Si el piso destino esta arriba del actual
					if (pos<piso){
						pos+=1;
						GPIOA->ODR &= 0x0;
						GPIOA->ODR |=(1<<(pos-1));
						t+=1;
					}
					else{
//Si el piso destino esta abajo del actual
						if(pos>piso){
							pos-=1;
							GPIOA->ODR &= 0x0;
							GPIOA->ODR |=(1<<(pos-1));
							t+=1;
						}
//Si se alcanza el piso destino cambiar de estado
//y borrar las variables del bóton
					if(pos==piso){
							piso=0;
							current_state=entrada_salida;
							cam=1;
							lock=0;
						}

					}
				}
				break;
			case Inmovil:
//Si se presiono el botón y el piso destino
//es distinto del actual pasa al estado en movimiento
				if((piso!=pos)&(cam==0)){
						current_state = En_Movimiento;
						lock=0;
				}else {
//Si el botón fue preionado pero el piso destino es igual
//  al actual, entonces pasa al estado entrada salida
					if((cam==0)&(piso==pos)){
						current_state = entrada_salida;
						lock=0;
				}
				}

				break;
			case entrada_salida:
//Enciende el led que indica que el ascensor ya no se esta moviendo
				GPIOA->ODR|=0x20;
//Abre las puertas del ascensor y el tiempo en que lo hace
				if (lock==0){
					t=con;
					lock=1;
					GPIOA->ODR |= 0x10;
					cam=1;
				}
//5 segundos despues de abrir la puerta
				if (con>(t+5)){
// pasa al estado inmovil
					current_state=Inmovil;
//Y cierra la puerta
					GPIOA->ODR &= ~(1<<4);

				}
				break;
		}// switch(current_state)
	} //while(true)


}
